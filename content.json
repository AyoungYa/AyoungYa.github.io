[{"title":"Excel打开代码生成CSV文件数字科学计数法显示问题","date":"2017-10-16T08:03:53.000Z","path":"undefined/Excel打开代码生成CSV文件数字科学计数法显示问题/","text":"在项目中用Java生成CSV文件，对于多位的数字用excel打开数字出现了科学计数法展示，为避免这个问题，找到如下修复方法： 在生成csv的时候,在数字的前面或后面加上”\\t”制表符，再用excel打开问题解决！如 “2017082021001004240505117583\\t”, “\\t201708202100100402052047”; 转载地址：http://zhejiangyinghui.iteye.com/blog/1149526","tags":[{"name":"Java","slug":"Java","permalink":"http://www.ayoungya.com/tags/Java/"}]},{"title":"Java-集合类初始化及相互转换","date":"2017-09-08T03:58:38.000Z","path":"undefined/Java-集合类初始化/","text":"问题在开发过程中，遇到一些Java集合类的初始化问题，在这里做个简单的总结。 初始化假设有如下类123456789101112131415161718public class Demo &#123; private int id; private String name; public Demo(int id, String name) &#123; this.id = id; this.name = name; &#125; @Override public String toString() &#123; final StringBuffer sb = new StringBuffer(\"Demo&#123;\"); sb.append(\"id=\").append(id); sb.append(\", name='\").append(name).append('\\''); sb.append('&#125;'); return sb.toString(); &#125;&#125; ArrayList方法1. 基本初始化方法 初始化一个List，里面包含两个Demo对象 1234567public static void initMethod1()&#123; List&lt;Demo&gt; demos = new ArrayList&lt;&gt;(); demos.add(new Demo(1, \"Iphone\")); demos.add(new Demo(2, \"Samsung\")); System.out.println(demos.toString()); &#125; 该方法特点 简单直观、易于理解 … 方法2. 静态初始化方法1234567public class ListInit &#123; private static List&lt;Demo&gt; staticDemoList = new ArrayList&lt;&gt;(); static &#123; staticDemoList.add(new Demo(3, \"Iphone\")); staticDemoList.add(new Demo(4, \"Samsung\")); &#125;&#125; 该方法特点 适用于静态集合的初始化 方法3. 双括号语法的使用123456public static void initMethod3()&#123; List&lt;Demo&gt; demoList = new ArrayList&lt;Demo&gt;()&#123;&#123; add(new Demo(5, \"Iphone\")); add(new Demo(6, \"Samsung\")); &#125;&#125;; &#125; 第一层括弧 实际是定义了一个内部匿名类 （Anonymous Inner Class），第二层括弧 实际上是一个实例初始化块 （instance initializer block），这个块在内部匿名类构造时被执行。这个块之所以被叫做“实例初始化块”是因为它们被定义在了一个类的实例范围内。这和“静态初始化块 （static initialzer）”不同，因为这种块在定义时在括弧前使用了static关键字，因此它的和类在同一个范围内的，也就是说当类加载时就会被执行（更详情，可参考Java语言规范http://java.sun.com/docs/books/jls/third_edition/html/classes.html#8.6 ）。实例初始化块中可以使用其容器范围内的所有方法及变量，但特别需要注意的是实例初始化块是在构造器之前运行的。 这种方法只适用于不是final的类，因为final类是无法建立内部匿名子类，好在集合类都没有这个限制。 方法4. Arrays.as使用12345public static void initMethod4()&#123; Demo demo7 = new Demo(7, \"Iphone\"); Demo demo8 = new Demo(6, \"Samsung\"); List&lt;Demo&gt; demos = Arrays.asList(demo7, demo8); &#125; 该方法是array和list之间的转换API，和Collection.toArray方法相呼应。使用该方法初始化的List需要注意以下： Arrays.asList生成的对象是Arrays的内部类ArrayList对象，不是java.util.ArrayList，该内部类只实现了List的部分方法，而没有实现add、remove，因此如果需要对例子中的demos进行add、remove操作时会报UnsupportedOperationException。 使用Arrays.asList有可能会出现类型转换的错误，转换后的结果不是想要的，如下1234567891011121314151617181920212223public static void main(String[] args) &#123; int[] intA = new int[]&#123;1, 2, 3&#125;; List listA = Arrays.asList(intA); System.out.println(\"listA type: \" + listA.getClass()); System.out.println(\"listA ele type: \" + listA.get(0).getClass()); Integer[] integerB = new Integer[]&#123;1, 2, 3&#125;; List bList1 = Arrays.asList(integerB); System.out.println(\"bList1 type: \" + bList1.getClass()); System.out.println(\"bList1 ele type: \" + bList1.get(0).getClass()); List&lt;Integer&gt; bList2 = Arrays.asList(integerB); System.out.println(\"bList2 type: \" + bList2.getClass()); System.out.println(\"bList2 ele type: \" + bList2.get(0).getClass());&#125;/** output* listA type: class java.util.Arrays$ArrayList* listA ele type: class [I* bList1 type: class java.util.Arrays$ArrayList* bList1 ele type: class java.lang.Integer* bList2 type: class java.util.Arrays$ArrayList* bList2 ele type: class java.lang.Integer*/ 其原因是Arrays.asList(T… a)接受变长参数导致的。在使用Arrays.asList时指定返回值类型可以避免一些引起的问题 方法5. Stream的使用12345public static void initMethod4()&#123; Demo demo7 = new Demo(7, \"Iphone\"); Demo demo8 = new Demo(6, \"Samsung\"); List&lt;Demo&gt; demos = Stream.of(demo7, demo8).collect(Collectors.toList()); &#125; 方法6. 集合类方法的使用1234567public static void initMethod7()&#123; int size = 100; int defaultValue = 0; List&lt;Integer&gt; integerList = Collections.nCopies(size, defaultValue); List&lt;Demo&gt; demos = Collections.nCopies(size, new Demo(0, \"\")); &#125; 方法7. Stream generate方法的使用HashMap 参考 Java技巧之双括弧初始化 java怎么用一行代码初始化ArrayList","tags":[{"name":"Java","slug":"Java","permalink":"http://www.ayoungya.com/tags/Java/"}]},{"title":"领域驱动入门(01)","date":"2017-09-04T11:58:51.000Z","path":"undefined/领域驱动入门(01)/","text":"本系列博客希望以Vaughn Vernon的《实现领域驱动设计》为参考，入坑领域驱动设计。 一、什么是领域驱动设计领域驱动设计(Domain Drive Design, DDD)是软件开发的一种方法，旨在帮助我们设计开发可测试、可伸缩、组织良好的软件模型。 DDD并不是画模型图，而是将领域专家的思维模型转化成有用的业务模型;DDD不是创建一个真实世界的模型，而是模仿现实。 二、DDD的价值业务价值 得到一个有用的领域模型 业务得到更准确的定义和理解 更好的用户体验 清晰的模型边界 更好的企业架构 敏捷、迭代式和持续建模 使用战略和战术新工具 三、挑战 为创建通用语言腾出时间和精力 我们需要花大量的时间和精力来思考业务领域，研究概念和术语，并且和领域专家交流以发现、捕捉和改进通用语言。 持续的将领域专家引入项目 改变开发者对领域的思考方式 四、关键概念 领域广义上来讲，领域指一个组织所做的事情及其中所包含的一切。领域既可以表示整个业务系统，又可以表示其中的某个核心域或者支撑子域。 子域 核心域 限界上下文 领域事件 通用语言 团队的共享语言，“同一个团队，同一种语言”。 关于业务本身如何思考和运作的。 团队交流和代码才是对通用语言的持续表达。 1).如何掌握通用语言 同时绘制物理模型图和概念模型图，并标以名字和行为; 创建一个包含简单定义的术语表; 采用其他类型的文档，将涉及到的模型包含，得到通用语言的术语和词组; 与其他成员套路通用语言并修正。 2). 通用语言注意点 通用是在团队范围内使用，并且只表达一个单一的领域模型; 通用语言不代表全企业、全公司或者全球性的领域语言; 限界上下文和通用语言是一对一的关系; 限界上下文是一个相对较小的概念。 五、Example后续将使用一套虚拟的产品介绍DDD的使用。 六、参考 DDD领域驱动设计基本理论知识总结","tags":[{"name":"DDD","slug":"DDD","permalink":"http://www.ayoungya.com/tags/DDD/"}]},{"title":"Java8 Stream","date":"2017-09-04T07:21:06.000Z","path":"undefined/Java8-Stream/","text":"","tags":[{"name":"java8","slug":"java8","permalink":"http://www.ayoungya.com/tags/java8/"},{"name":"stream","slug":"stream","permalink":"http://www.ayoungya.com/tags/stream/"}]},{"title":"个人效率提升方法","date":"2017-09-03T08:31:53.000Z","path":"undefined/个人效率提升方法/","text":"","tags":[{"name":"效率","slug":"效率","permalink":"http://www.ayoungya.com/tags/效率/"}]},{"title":"集体智慧编程--搜索排序算法","date":"2017-04-30T15:28:23.000Z","path":"machinelearning/集体智慧编程-搜索排序算法/","text":"基于内容的排名单词频度文档位置单词距离利用外部回指链接简单计数PageRank算法利用连接文本","tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://www.ayoungya.com/tags/机器学习/"},{"name":"搜索排序","slug":"搜索排序","permalink":"http://www.ayoungya.com/tags/搜索排序/"},{"name":"集体智慧编程","slug":"集体智慧编程","permalink":"http://www.ayoungya.com/tags/集体智慧编程/"}]},{"title":"集体智慧编程--概率与统计学中的一些基本概念","date":"2017-04-27T16:02:10.000Z","path":"machineLearning/集体智慧编程--概率与统计学中的一些基本概念/","text":"这里主要用于介绍机器学习和数据挖掘中常用的一些统计学概念及计算公式 欧几里得距离(欧氏距离 Euclidean Distance)欧式距离是指多维空间中两点的距离，是直线距离。假设有点$A(p_1, p_2, … p_n) $, $B(q_1, q_2, … q_n)$, 其中n为空间的维度，那么AB之间的欧式距离为下面公式所示： $$ D = \\sqrt{\\sum_{i=1}^{n}(p_i-q_i)^2 } = \\sqrt{(p_1-q_1)^2 + (p_2-q_2)^2+…+(p_n-q_n)^2}$$ python代码 12345678from math import sqrtdef euclidean(v1, v2): if len(v1) != len(v2) or len(v1) &lt;= 0: return 0.0 return sqrt(sum([(v1[i] - v2[i]) ** 2 for i in xrange(len(v1))])) 皮尔逊相关系数(Pearson Correlation Coefficient)皮尔逊相关系数是一种度量两个变量间相关程度的方法。值介于-1～+1之间，如果值为+1则表示变量完全正相关，0表示无关，-1表示完全负相关。计算公式如下$$ r=\\frac{\\sum(XY)-\\frac{\\sum(X)\\sum(Y)}{N}}{\\sqrt{(\\sum{X^2}-\\frac{(\\sum{X})^2}{N})(\\sum{Y^2-\\frac{(\\sum{Y})^2}{N}})}}$$ 计算方式：12345678910111213141516171819202122from math import sqrtdef pearson(v1, v2): if len(v1) != len(v2): print(\"len(v1) != len(v2). len(v1) = %d, len(v2) = %d\" % (len(v1), len(v2))) return 0 length = len(v1) sum_v1 = 1.0 * sum(v1) sum_v2 = 1.0 * sum(v2) sum_v1_sq = 1.0 * sum([v ** 2 for v in v1]) sum_v2_sq = 1.0 * sum([v ** 2 for v in v2]) p_sum = 1.0 * sum([v1[i] * v2[i] for i in xrange(length)]) num = p_sum - (sum_v1 * sum_v2 / length) den = sqrt((sum_v1_sq - pow(sum_v1, 2) / length) * (sum_v2_sq - pow(sum_v2, 2) / length)) if den == 0: return 0 return num / den 加权平均(Weighted Mean)加权平均是对参与平均运算的每一个观测变量都有一个对应的权重值。具体公式如下：$$ \\bar{x} = \\frac{w_1x_1 + w_2x_2+…+w_nx_n}{w_1+w_2+…+w_n} $$ 计算方式1234567def weightedmen(x, w): if len(x) != len(w): return 0 num = 1.0 * sum([x[i] * w[i] for i in xrange(len(x))]) den = sum([w[i] for i in xrange(len(x))]) return num/den 参考 集体智慧编程","tags":[{"name":"几何距离","slug":"几何距离","permalink":"http://www.ayoungya.com/tags/几何距离/"},{"name":"统计学","slug":"统计学","permalink":"http://www.ayoungya.com/tags/统计学/"}]},{"title":"Mysql数据插入","date":"2017-04-22T09:27:56.000Z","path":"mysql/Mysql数据插入/","text":"数据库中四大操作：增、删、查、改。每个操作都有若干种方法得到结果，在这个小结中主要介绍一下MySQL的“增”，这里的增是指在数据表中增加／插入数据。主要有以下几种方法: 基本插入方法—INSERT这是Mysql中最常见的方法了，语法结构有以下两种 普通的插入 1INSERT INTO table_name VALUES(null, 拿破仑, 38, 份); 这是一种不安全的插入方式，应当尽量避免使用在插入的数据中，没有明确给出列名，因此每个值必须与数据表中的字段名按顺序一一对应，并且对空值字段也要赋值。 相比第一条列出的插入方法，下面这种方法更加安全有效， 1INSERT INTO table_name(id, name, price, measurement) VALUES(null, 拿破仑, 38, 份); 在这条中对每个需要赋值的字段名列出，然后再一一赋值。这样，即使不知道数据库表中字段的顺序也能很好的插入数据，如果其中某些字段不需要赋值也能很好的解决。另外对于一次性插入多行数据只要在VALUE后列出所有的数据即可。对于不赋值的数据，应该满足以下要求：1. 该列允许定义为NULL; 2. 该列可以有默认值，如果不赋值将赋予默认值。 选择插入—INSERT…SELECT1INSERT INTO new_table VALUES(name, price, measurement) SELECT name, price, measurement FROM old_talbe WHERE id = 1; 该语句表示将old表中满足特定条件的数据检索出来并插入到new_table中。 去重插入—REPLACE、ON DUPLICATE KEY UPDATE去重插入是该小结的重点: 在插入数据的时候，我们经常会遇到要先判断数据是否存在，如果存在则进行修改，不存在再对其进行插入。这部分将介绍几种避免重复插入的方法： 1REPLACE INTO table_name(id, name, price, measurement) VALUES(1, 拿破仑, 40, 份); 该语句是insert语句的加强版，只是在插入数据的过程中将会执行两个动作： (1) 判定该数据是否存在；(2) 如果存在则进行删除旧的数据，再插入新的值（影响表中的两行数据），如果不存在则进行插入造作（影响一行数据）。 该方法能够避免重复插入有特定约束条件的数据，比如主键（PRIMARY KEY）或者是唯一索引(UNIQUE KEY)，但是如果没有这些约束条件，Replace就和Insert语句一样了。另外要使用Replace语句，必须同时拥有insert和delete权限。 另外一种去除重复插入的方法就是使用INSERT...ON DUPLICATE KEY UPDATE，实例如：1INSERT INTO table_name(id, name, price, measurement) VALUES(1, 拿破仑, 40, 份) ON DUPLICATE KEY UPDATE price = 40; 该方法也会对重复的值进行先删后插入(影响行数可能为1或2)的操作，与Replace类似。 参考资源 向MySQL数据表插入行记录（INSERT） ON DUPLICATE KEY UPDATE重复插入时更新","tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.ayoungya.com/tags/mysql/"},{"name":"数据库","slug":"数据库","permalink":"http://www.ayoungya.com/tags/数据库/"}]},{"title":"概率论--蒙特霍尔悖论","date":"2017-04-18T12:00:32.000Z","path":"machineLearning/概率论-蒙特霍尔悖论/","text":"引例&#160; &#160; &#160; &#160;在电视节目中，有三个门(编号1，2，3)供选手选择，其中一个门后有丰厚奖品(如一辆汽车)，另外两个门后只有很少的奖品(如一只羊)。 现在选手选择了2号门，主持人打开了1号门，发现里面是一只羊，主持人问选手是否改选3号门， 作为选手是否应该放弃已选的2号门改选3号门还是坚持2号门才更容易中汽车呢？ 描述&#160; &#160; &#160; &#160;蒙特霍尔悖论(蒙特霍尔问题或者三门问题)，是一个源自博弈论的数学游戏问题，问题源于电视节目主持人蒙特霍尔。问题的描述如上面的Example所示。问题的结论是如果选手在主持人打开一扇门后选择另外一扇门，得到大奖的概率是2/3。 解答&#160; &#160; &#160; &#160;问题的解答可以参看玛丽莲·沃斯·莎凡特(80年代吉尼斯纪录认定的最高智商的女性)的解答: 当参赛者转向另一扇门而不是继续维持原先的选择时，赢得汽车的机会将会加倍。 有三种可能的情况，全部都有相等的可能性（1/3）: 选手挑汽车，主持人挑两头羊的任何一头。转换将失败。 选手挑A羊，主持人挑B羊。转换将赢得汽车。 选手挑B羊，主持人挑A羊。转换将赢得汽车。 &#160; &#160; &#160; &#160;这里我们可以用一个放大一些的列子来简化问题：有100个门，其中1个门后是有汽车的，其余99个后面是门有汽车的，现在你选择了其中的任意一个(比如35号)，那么你中奖的概率是1%，然后打开了那99扇门中没有奖品的98扇门只剩下23号门没有打开，那么23号门中奖的概率就是99%。所以如果可以，你应该毫不犹豫的选择23号门。同样，在这里选择另外一扇门是可以提高中奖概率的。 结论对概率的本能理解有时候会将你引入歧途。 [美]查尔斯·韦兰--赤裸裸的统计学：除去大数据的枯燥外衣 参考 蒙特霍尔问题-维基百科 赤裸裸的统计学-豆瓣","tags":[{"name":"蒙特霍尔","slug":"蒙特霍尔","permalink":"http://www.ayoungya.com/tags/蒙特霍尔/"},{"name":"三门问题","slug":"三门问题","permalink":"http://www.ayoungya.com/tags/三门问题/"},{"name":"概率论","slug":"概率论","permalink":"http://www.ayoungya.com/tags/概率论/"}]},{"title":"基于Github的个人博客搭建","date":"2017-04-06T13:31:14.000Z","path":"blog/基于Github的个人博客搭建/","text":"&#160; &#160; &#160; &#160;出于兴趣或者其他原因，我们都期望搭一个个性化的个人博客，对比各种其他方式，通过Hexo + Github搭建一套博客系统是投入产出比最大的方式了。本文将介绍如何利用这两种工具搭建一个属于自己的博客。Let’s start right now! 1. 基本资源准备1.1 本地电脑配置 Git, 一个开源的版本控制器，在这里主要是控制博客的内容以及用于将内容推送到远端的Github上或者其他代码托管平台. Window版提供客户端和shell两种版本下载地址, 安装过程可参看百度经验或者其他博客。 Node.js: 整个博客的语言环境，这里的语言指的是编程语言（是不是有点啰嗦呢^_^）。 Hexo: 整个博客系统的核心部件，负责运转整个系统包括博客的初始化，外观的渲染，博客内容的添加…。 1.2 网络资源申请 Github账号的申请及本地的初始化Github简明教程(非官方)。 域名 非必需，基于github配置好之后的地址样式如 your_github_name.github.io. 如果想让自己的博客又一个比较个性化的地址， 可以申请一个。 2. Start在网上已经有大量的基本的配置教程，这里就不再详细叙述了，用户可以自行百度或者Google安装，相关的关键词主要有：hexo、静态博客搭建等。 3. 个性化定制3.1 自定义主题 首先选择喜欢的主题，参看网上的一些主题库：官方主题, 知乎上的回答 将选择的主题下到本地，然后放到主文件夹的thems目录下; 找到博客的_config.yml文件，设置theme:为当前的主题; 找到自定义主题的_config.yml文件，进行个性化定制即可。 3.2 个性化头像设置自己的头像一般是根据主题不同而会略有差异，在这里以我所使用的yilia主题为例。头像图片可以放置在两个地方：一个是网上的图床，你可以选择一个图床将博客中所有的图片都放在里面，然后在博客中只需要插上对应的链接即可；另外一种是放到博客的文件夹中并上传到Github上，一般是在source/img文件夹中，如果没有则新建一个即可。 在这里我们先把头像图片放到source/img中； 找到yilia主题的_config.yml的avatar字段，设置值为img/header.jpg 本地重启Hexo，应该可以看到自定义的头像；执行hexo clean; hexo g -d部署到线上即可。 3.3 添加评论功能&#160; &#160; &#160; &#160;对于Yilia主题，主流支持的第三方评论是多说和Disqus，不幸的是这两个在国内逐渐不好用了。首先是多说，它是国内比较好的第三方评论系统但是在2017年6月即将关闭，这对于众多的多说用户来说都是一个不小的迁移工作，所以我们这里不采用多说；Disqus也不推荐，因为它已经被关在墙外面了:( 其他的评论系统有搜狐的畅言、网易的云跟帖、有言等等。 个人感觉畅言的视觉效果不如云跟帖和有言，因此选择了云跟帖作为本博客的评论。添加的过程如下： 在网易的云跟帖中进行账号的注册和相关信息的补充以及样式选择。 然后在获取代码页面copy对应的js代码，如下图所示 找到thems/yilia/layout/post/duoshuo.ejs,用刚才的代码覆盖原有的代码，之后的代码如下： 123456789101112&lt;div class=\"duoshuo\"&gt; &lt;div id=\"cloud-tie-wrapper\" class=\"cloud-tie-wrapper\"&gt;&lt;/div&gt; &lt;script&gt; var cloudTieConfig = &#123; url: document.location.href, sourceId: \"\", productKey: \"your_key_is_here\", target: \"cloud-tie-wrapper\" &#125;; &lt;/script&gt; &lt;script src=\"https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js\"&gt;&lt;/script&gt;&lt;/div&gt; 在yilia的_config.yml中设置duoshuo: true 在需要评论的文章Front-matter部分设置 comments: true 重新deploy到线上即可看到想要的评论框了。 2017-04-20Remark：当前评论存在的问题是对一篇文章进行评论后发现其他的文章也有这条评论了，也就是评论混淆了。需要重点解决 3.4 自定义文章分类 Hexo的文件夹功能其实是一个类似文件链接的功能，所有的已发表的文章均放在source/_posts文件夹下面，如果需要分类到不同的类别下，可以通过Hexo自带的类别功能进行分类。大概步骤可以参看知乎的回答 3.5 添加百度统计功能百度的统计功能安装比较简单，只要进行下面几步就好了 注册百度统计的账号并补充对应的信息. 找到代码对应的key，并把这个Key粘贴到yillia的_config.yml的baidu_analytics字段中 123456789&lt;script&gt; var _hmt = _hmt || []; (function() &#123; var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?your_key_is\"; //Here is your key var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); &#125;)();&lt;/script&gt; 执行hexo clean; hexo g -d命令重新部署Hexo，稍等一会进行百度统计代码安装检查（前面的百度统计页面） 开始你的Blog hexo new post blog_name，然后在source/_posts下面找到对应的md格式文档进行编辑即可。 对于文档的编辑，可以参看Hexo的官方教程. 参考文章 Hexo 知乎的回答","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.ayoungya.com/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"http://www.ayoungya.com/tags/Github/"},{"name":"Blog","slug":"Blog","permalink":"http://www.ayoungya.com/tags/Blog/"},{"name":"云跟帖","slug":"云跟帖","permalink":"http://www.ayoungya.com/tags/云跟帖/"}]},{"title":"Hello World","date":"2015-04-06T07:16:21.000Z","path":"blog/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.ayoungya.com/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"http://www.ayoungya.com/tags/Github/"},{"name":"Blog","slug":"Blog","permalink":"http://www.ayoungya.com/tags/Blog/"}]}]